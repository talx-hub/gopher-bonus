// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: orders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addAccruedAmount = `-- name: AddAccruedAmount :exec
INSERT INTO accruals (id_acc_order, amount)
VALUES ((SELECT id_acc_order
         FROM accrued_orders
         WHERE order_no=$1),
        $2)
`

type AddAccruedAmountParams struct {
	OrderNo string
	Amount  pgtype.Numeric
}

func (q *Queries) AddAccruedAmount(ctx context.Context, arg AddAccruedAmountParams) error {
	_, err := q.db.Exec(ctx, addAccruedAmount, arg.OrderNo, arg.Amount)
	return err
}

const createOrder = `-- name: CreateOrder :exec
INSERT INTO accrued_orders (id_user, order_no, uploaded_at, id_status)
VALUES ($1, $2, $3,
        (SELECT public.statuses.id_status
         FROM statuses
         WHERE name_status=$4))
`

type CreateOrderParams struct {
	IDUser     int32
	OrderNo    string
	UploadedAt pgtype.Timestamptz
	NameStatus string
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) error {
	_, err := q.db.Exec(ctx, createOrder,
		arg.IDUser,
		arg.OrderNo,
		arg.UploadedAt,
		arg.NameStatus,
	)
	return err
}

const findOrderByID = `-- name: FindOrderByID :one
SELECT id_user FROM accrued_orders
WHERE order_no=$1
`

func (q *Queries) FindOrderByID(ctx context.Context, orderNo string) (int32, error) {
	row := q.db.QueryRow(ctx, findOrderByID, orderNo)
	var id_user int32
	err := row.Scan(&id_user)
	return id_user, err
}

const listByUserID = `-- name: ListByUserID :many
SELECT acc_o.order_no, statuses.name_status, uploaded_at, public.accruals.amount AS accrual
FROM accrued_orders AS acc_o
    JOIN statuses ON acc_o.id_status = statuses.id_status
    JOIN public.accruals ON acc_o.id_acc_order = public.accruals.id_acc_order
WHERE acc_o.id_user=$1
`

type ListByUserIDRow struct {
	OrderNo    string
	NameStatus string
	UploadedAt pgtype.Timestamptz
	Accrual    pgtype.Numeric
}

func (q *Queries) ListByUserID(ctx context.Context, idUser int32) ([]ListByUserIDRow, error) {
	rows, err := q.db.Query(ctx, listByUserID, idUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListByUserIDRow
	for rows.Next() {
		var i ListByUserIDRow
		if err := rows.Scan(
			&i.OrderNo,
			&i.NameStatus,
			&i.UploadedAt,
			&i.Accrual,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStatus = `-- name: UpdateStatus :exec
UPDATE accrued_orders
SET id_status=(
    SELECT id_status
    FROM statuses
    WHERE name_status=$1)
WHERE order_no=$2
`

type UpdateStatusParams struct {
	NameStatus string
	OrderNo    string
}

func (q *Queries) UpdateStatus(ctx context.Context, arg UpdateStatusParams) error {
	_, err := q.db.Exec(ctx, updateStatus, arg.NameStatus, arg.OrderNo)
	return err
}
