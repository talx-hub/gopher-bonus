// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package db

import (
	"context"
)

const exists = `-- name: Exists :one
SELECT EXISTS(SELECT 1
              FROM user_hashes
              WHERE hash_login = $1)
`

func (q *Queries) Exists(ctx context.Context, hashLogin string) (bool, error) {
	row := q.db.QueryRow(ctx, exists, hashLogin)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const findUserByID = `-- name: FindUserByID :one
SELECT user_hashes.id_user, user_hashes.hash_login, ph.hash_password
FROM user_hashes JOIN password_hashes ph on user_hashes.id_user = ph.id_user
WHERE user_hashes.id_user = $1
`

type FindUserByIDRow struct {
	IDUser       int32
	HashLogin    string
	HashPassword string
}

func (q *Queries) FindUserByID(ctx context.Context, idUser int32) (FindUserByIDRow, error) {
	row := q.db.QueryRow(ctx, findUserByID, idUser)
	var i FindUserByIDRow
	err := row.Scan(&i.IDUser, &i.HashLogin, &i.HashPassword)
	return i, err
}

const findUserByLogin = `-- name: FindUserByLogin :one
SELECT user_hashes.id_user, user_hashes.hash_login, ph.hash_password
FROM user_hashes JOIN password_hashes ph on user_hashes.id_user = ph.id_user
WHERE hash_login = $1
`

type FindUserByLoginRow struct {
	IDUser       int32
	HashLogin    string
	HashPassword string
}

func (q *Queries) FindUserByLogin(ctx context.Context, hashLogin string) (FindUserByLoginRow, error) {
	row := q.db.QueryRow(ctx, findUserByLogin, hashLogin)
	var i FindUserByLoginRow
	err := row.Scan(&i.IDUser, &i.HashLogin, &i.HashPassword)
	return i, err
}

const insertLoginHash = `-- name: InsertLoginHash :one
INSERT INTO user_hashes (hash_login)
VALUES ($1)
RETURNING id_user
`

func (q *Queries) InsertLoginHash(ctx context.Context, hashLogin string) (int32, error) {
	row := q.db.QueryRow(ctx, insertLoginHash, hashLogin)
	var id_user int32
	err := row.Scan(&id_user)
	return id_user, err
}

const insertPasswordHash = `-- name: InsertPasswordHash :exec
INSERT INTO password_hashes (id_user, hash_password)
VALUES ($1, $2)
`

type InsertPasswordHashParams struct {
	IDUser       int32
	HashPassword string
}

func (q *Queries) InsertPasswordHash(ctx context.Context, arg InsertPasswordHashParams) error {
	_, err := q.db.Exec(ctx, insertPasswordHash, arg.IDUser, arg.HashPassword)
	return err
}
